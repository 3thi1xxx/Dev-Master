{
  "drop_id": "axiom-wire-l2-{{TIMESTAMP}}",
  "provider": "ChatGPT",
  "dry_run": false,
  "policy": { "require_council": false, "allow_fs_mutation": true },
  "metadata": { "source": "axiom-scaffold-v2", "purpose": "wire-l2-pipeline" },
  "intents": [
    {
      "kind": "file_write",
      "path": "scripts/axiomWireL2.mjs",
      "mode": "0644",
      "content": "#!/usr/bin/env node\n// Axiom Wire L2 — queue-backed paper pipeline using AxiomAdapter as decision stage.\n// Safe-by-default: killswitch + trust enforced, TradeSim only. Anchored proof logs.\nimport fs from 'fs';\nimport fsp from 'fs/promises';\nimport path from 'path';\nimport url from 'url';\nimport crypto from 'crypto';\nconst ROOT=process.cwd();\nconst VAULT_LOG=path.join(ROOT,'vault-log.ndjson');\nconst PMAC=path.join(ROOT,'.pmac.log');\nconst AR=path.join(ROOT,'vault-anchors','anchor.json');\nfunction now(){return new Date().toISOString()}\nfunction ensureDir(p){fs.mkdirSync(p,{recursive:true})}\nfunction jget(p,fallback){try{return JSON.parse(fs.readFileSync(p,'utf8'))}catch{return fallback}}\nfunction jset(p,obj){ensureDir(path.dirname(p));fs.writeFileSync(p,JSON.stringify(obj,null,2))}\nfunction sha(x){return crypto.createHash('sha256').update(typeof x==='string'?x:JSON.stringify(x)).digest('hex')}\nfunction readAnchor(){return jget(AR,{parents:'GENESIS',anchor_hash:'',count:0})}\nfunction writeAnchor(payload_hash){const prev=readAnchor();const parents=prev.anchor_hash||'GENESIS';const anchor_hash=sha(parents+payload_hash);const s={parents,payload_hash,anchor_hash,ts:now(),count:(prev.count||0)+1};jset(AR,s);return s}\nfunction logEvt(type,payload){const payload_hash=sha(payload);const anchor=writeAnchor(payload_hash);const ev={ts:now(),type,payload,payload_hash,anchor};ensureDir(path.dirname(VAULT_LOG));fs.appendFileSync(VAULT_LOG,JSON.stringify(ev)+'\\n');fs.appendFileSync(PMAC,JSON.stringify({ts:ev.ts,level:'INFO',event:type,anchor:anchor.anchor_hash})+'\\n');return ev}\nasync function importMaybe(paths){for(const rel of paths){const abs=path.join(ROOT,rel);if(fs.existsSync(abs)){return await import(url.pathToFileURL(abs).href)}}return null}\nasync function getQueue(){const mod=await importMaybe(['src/queue/QueueManager.js','src/QueueManager.js','QueueManager.js']);if(mod){const C=mod.default??mod.QueueManager??mod.queue??mod;try{if(typeof C==='function')return new C({name:'axiom-wire-l2'});if(C?.publish&&C?.subscribe)return C;}catch{}}// stub fallback if missing\nconst stub='scripts/stubs/QueueManager.js';const abs=path.join(ROOT,stub);if(!fs.existsSync(abs)){ensureDir(path.dirname(abs));fs.writeFileSync(abs,`export default class QueueManager{constructor(){this.topics=new Map()}publish(t,p){const q=this.topics.get(t)||this.topics.set(t,[]).get(t);const m={id:'msg_'+Date.now()+'_'+Math.random().toString(36).slice(2),topic:t,payload:p,ts:new Date().toISOString()};q.push(m);return m.id}subscribe(t,h){if(!this.topics.has(t))this.topics.set(t,[]);const q=this.topics.get(t);const iv=setInterval(async()=>{const m=q.shift();if(!m)return;await h(m)},20);return{close:()=>clearInterval(iv)}}size(t){return(this.topics.get(t)||[]).length}}`) } logEvt('queue_stub_used',{path:stub}); return (await import(url.pathToFileURL(abs).href)).default?new (await import(url.pathToFileURL(abs).href)).default():new (await import(url.pathToFileURL(abs).href)).default }\nasync function main(){const args=process.argv.slice(2);const durA=args.find(a=>a.startsWith('--duration='));const conA=args.find(a=>a.startsWith('--concurrency='));const D=durA?Number(durA.split('=')[1]):60;const C=conA?Number(conA.split('=')[1]):2;const trust=jget(path.join(ROOT,'config','trust-policy.json'),{thresholds:{min_trust_to_execute:0.7,per_symbol_cap_usd:250}});const kill=jget(path.join(ROOT,'killswitches','global.json'),{enabled:false});const queue=await getQueue();const A=await importMaybe(['agents/trading/AxiomAdapter.js','agents/trading/AxiomAdapter.mjs']);if(!A)throw new Error('AxiomAdapter missing');const TS=await importMaybe(['agents/TradeSimExecutor.js','agents/TradeSimExecutor.mjs','agents/TradeSimExecutor.cjs']);const runTS=(TS?.default?.run)||TS?.run; if(typeof runTS!=='function'){// minimal internal sim if executor absent\n globalThis.__sim= true; } const DF=await importMaybe(['agents/DataFetcherExecutor.js']); const runDF=(DF?.default?.run)||DF?.run|| (async ({lastPrice})=>({price: Math.max(1, (lastPrice||100)*(0.999+Math.random()*0.002))}))\n// load fixtures\nlet pulse=[],tokens=[]; try{pulse=JSON.parse(await fsp.readFile('fixtures/axiom/pulse.sample.json','utf8')).items||[]}catch{} try{tokens=JSON.parse(await fsp.readFile('fixtures/axiom/tokens.sample.json','utf8')).items||[]}catch{} const baseSignals=[...pulse.slice(0,5).map(p=>({symbol:p.symbol,score:p.score,sizeUSD:10,reason:'pulse'})),...tokens.slice(0,5).map(t=>({symbol:t.symbol,score:t.score,sizeUSD:10,reason:'token'}))].filter(s=>s.symbol)\nconst topic='trade.pipeline.axiom'; const state={positionQty:0,lastPrice:100,positionUsd:0,dayLossPct:0}; const ctr={published:0,consumed:0,signals:0,buy:0,sell:0,hold:0,blocks:0,trades:0};\n// consumers\nconst workers=[]; for(let i=0;i<C;i++){workers.push(queue.subscribe(topic, async (msg)=>{ctr.consumed++; const ks=jget(path.join(ROOT,'killswitches','global.json'),{enabled:false}); if(ks.enabled){logEvt('autopilot_block',{reason:'killswitch_enabled',at:'queue_boundary'});ctr.blocks++;return;} const data=await runDF({seed:Math.floor(Math.random()*1e9),lastPrice:state.lastPrice,symbol:'TEST-USD'}); const cfg=jget(path.join(ROOT,'config','axiom.config.json'),{maxSlippage:0.01,maxPositionUSD:25,dryRun:true}); const actions=A.signalsToActions(baseSignals,cfg); const actionRaw=(actions[ctr.signals % Math.max(1,actions.length)]||{}); const action=(actionRaw?.side)||'BUY'; const conf=Number(actionRaw?.confidence??0.6); ctr.signals++; ctr[action.toLowerCase()]=(ctr[action.toLowerCase()]||0)+1; // trust cap gate\n const usd=Math.min(actionRaw?.notionalUSD||10, trust.thresholds?.per_symbol_cap_usd||250); if(usd<=0){logEvt('autopilot_block',{reason:'size_zero'});ctr.blocks++;return;} // paper trade\n let filled=false; if(globalThis.__sim){ // simple sim\n  const qty=usd/Math.max(1,data.price); state.positionQty += (action==='BUY'?qty:-qty); state.lastPrice=data.price; state.positionUsd=state.positionQty*data.price; filled=true; logEvt('paper_trade_executed',{symbol:actionRaw?.symbol||'TEST',side:action,qty,price:data.price,usd,ts:now()}); ctr.trades++; } else { const r=await runTS({decision:{action},data,state,risk:{sizeUsd:usd}}); if(r?.filled){ state.positionQty=r.positionQty; state.lastPrice=r.lastPrice; state.positionUsd=state.positionQty*data.price; ctr.trades++; logEvt('paper_trade_executed', r.fill); } } if((ctr.consumed%10)===0){ const feed={ taskId:`axiom-wire-l2-${Date.now()}`, published:ctr.published, consumed:ctr.consumed, signals:ctr.signals, buy:ctr.buy, sell:ctr.sell, hold:ctr.hold, blocks:ctr.blocks, trades:ctr.trades, queueSize:(queue.size?queue.size(topic):null) }; ensureDir(path.join(ROOT,'reports')); await fsp.writeFile(path.join(ROOT,'reports','axiom-signal-feed.json'), JSON.stringify(feed,null,2)); logEvt('axiom_signal_update',feed);} }))} \n// publisher\nconst end=Date.now()+D*1000; while(Date.now()<end){ const id=queue.publish(topic,{ts:now()}); ctr.published++; logEvt('queue_publish',{topic,id,axiom:true}); await new Promise(r=>setTimeout(r,250)); } await new Promise(r=>setTimeout(r,1200)); for(const w of workers){ if(typeof w?.close==='function') w.close(); } // report\nensureDir(path.join(ROOT,'reports')); const html=`<!doctype html><html><head><meta charset=\"utf-8\"><title>Axiom Wire L2</title></head><body><h1>Axiom Wire L2 – Paper</h1><p>Generated: ${now()}</p><pre>${JSON.stringify(ctr,null,2)}</pre><ul><li>Feed: reports/axiom-signal-feed.json</li><li>Vault Log: vault-log.ndjson</li></ul></body></html>`; await fsp.writeFile(path.join(ROOT,'reports','axiom-wire-l2.html'), html); logEvt('axiom_wire_l2_complete',{counters:ctr}); console.log('[axiom-wire-l2] complete') }\nmain().catch(e=>{fs.appendFileSync(PMAC,JSON.stringify({ts:now(),level:'ERROR',error:String(e?.stack||e)})+'\\n');console.error(e);process.exit(1)})\n"
    },
    {
      "kind": "file_write",
      "path": "cbsh/oneshot-axiom-wire-l2.sh",
      "mode": "0755",
      "content": "#!/usr/bin/env bash\nset -euo pipefail\nDUR=${1:---duration 30}\nCONC=${2:---concurrency 2}\nnode scripts/axiomWireL2.mjs \"$DUR\" \"$CONC\"\necho \"\nOpen reports/axiom-wire-l2.html\"\n"
    },
    {
      "kind": "file_write",
      "path": "public/widgets/axiom-signal-widget.js",
      "mode": "0644",
      "content": "(function(){ async function tick(){ try{ const r=await fetch('reports/axiom-signal-feed.json?ts='+Date.now()); if(!r.ok) throw new Error('fetch'); const s=await r.json(); const el=document.getElementById('axiom-signal-body'); if(!el) return; el.innerHTML=['<div>Signals: <b>'+s.signals+'</b> | BUY '+s.buy+' / SELL '+s.sell+' / HOLD '+s.hold+'</div>','<div>Trades: <b>'+s.trades+'</b> | Blocks '+s.blocks+'</div>','<div>Q size: '+s.queueSize+'</div>','<div>Run: '+String(s.taskId||'n/a').slice(0,14)+'</div>'].join(''); }catch(e){ const el=document.getElementById('axiom-signal-body'); if(el) el.textContent='No status yet…' } } setInterval(tick,1500); tick(); })();\n"
    },
    {
      "kind": "file_write",
      "path": "cbsh/patch-gui-axiom-widget.sh",
      "mode": "0755",
      "content": "#!/usr/bin/env bash\nset -euo pipefail\nROOT=\"$(pwd)\"\nCANDS=(\"ChadControlPanel.html\" \"public/ChadControlPanel.html\" \"src/gui/ChadControlPanel.html\" \"gui/ChadControlPanel.html\")\nFOUND=\"\"\nfor c in \"${CANDS[@]}\"; do if [[ -f \"$c\" ]]; then FOUND=\"$c\"; break; fi; done\nif [[ -z \"$FOUND\" ]]; then echo \"no ControlPanel found\"; exit 0; fi\ncp \"$FOUND\" \"$FOUND.bak\"\npython3 - \"$FOUND\" <<'PY'\nimport sys,re\np=sys.argv[1]\ns=open(p,'r',encoding='utf-8',errors='ignore').read()\nif 'id=\"axiom-signal-widget\"' in s:\n  print('widget already present');sys.exit(0)\nwidget='''\n<!-- AUTO-INJECT: Axiom Signal Widget -->\n<div id=\"axiom-signal-widget\" style=\"position:fixed;right:16px;bottom:84px;z-index:9999;font:12px/1.4 system-ui;background:#111;color:#eee;border:1px solid #333;border-radius:8px;padding:10px 12px;box-shadow:0 2px 12px rgba(0,0,0,0.5);\">\n  <div style=\"font-weight:600;margin-bottom:6px;\">Axiom Signals</div>\n  <div id=\"axiom-signal-body\">Loading…</div>\n</div>\n<script src=\"public/widgets/axiom-signal-widget.js\"></script>\n<!-- /AUTO-INJECT -->\n'''\ns=re.sub(r\"</body>\\s*</html>\\s*$\", widget+\"\\n</body></html>\", s, flags=re.I)\nopen(p,'w',encoding='utf-8').write(s)\nprint('patched',p)\nPY\n"
    },
    {
      "kind": "file_write",
      "path": "cbsh/axiom-killswitch-drill.sh",
      "mode": "0755",
      "content": "#!/usr/bin/env bash\nset -euo pipefail\nKS=\"killswitches/global.json\"\nmkdir -p killswitches\nnode -e \"const fs=require('fs');const p='${KS}';let o={enabled:false,reason:'',ts:new Date().toISOString()};try{o=JSON.parse(fs.readFileSync(p,'utf8'))}catch{};o.enabled=true;o.reason='axiom-drill';o.ts=new Date().toISOString();fs.writeFileSync(p,JSON.stringify(o,null,2));console.log('killswitch enabled')\"\nnode scripts/axiomWireL2.mjs --duration=5 --concurrency=1 || true\nnode -e \"const fs=require('fs');const p='${KS}';let o=JSON.parse(fs.readFileSync(p,'utf8'));o.enabled=false;o.reason='';o.ts=new Date().toISOString();fs.writeFileSync(p,JSON.stringify(o,null,2));console.log('killswitch disabled')\"\n"
    },
    {
      "kind": "file_write",
      "path": "cbsh/prune-logs.sh",
      "mode": "0755",
      "content": "#!/usr/bin/env bash\nset -euo pipefail\nMAX=${1:-25} # MB\nfor f in vault-log.ndjson .pmac.log; do\n  [[ -f \"$f\" ]] || continue;\n  SZ=$(du -m \"$f\" | awk '{print $1}')\n  if (( SZ > MAX )); then\n    TS=$(date -u +%Y%m%dT%H%M%SZ)\n    gzip -c \"$f\" > \"$f.$TS.gz\"\n    : > \"$f\"\n    echo \"[prune] rotated $f -> $f.$TS.gz\"\n  fi\ndone\n"
    }
  ]
} 